<template lang="pug">
  v-layout.py-2(column)
    kpi-widget-filters.mx-3(
      :widget-id="widget._id",
      :user-filters="userPreference.filters",
      :widget-filters="widget.filters",
      :locked-value="lockedFilter",
      :filters="mainFilter",
      :interval="query.interval",
      :sampling="query.sampling",
      :min-interval-date="minAvailableDate",
      :show-interval="showInterval",
      :show-filter="showFilter",
      :filter-disabled="!filterDisabled",
      :filter-addable="filterAddable",
      :filter-editable="filterEditable",
      @update:filters="updateSelectedFilter",
      @update:interval="updateInterval"
    )
    v-layout(column)
      c-progress-overlay(:pending="mainRatingSettingsPending", transition)
      c-advanced-data-table.pre-line(
        :items="preparedGroupMetrics",
        :loading="groupMetricsPending",
        :headers="headers",
        :total-items="groupMetricsMeta.total_count",
        no-pagination
      )
</template>

<script>
import { pick, find } from 'lodash';
import { createNamespacedHelpers } from 'vuex';

import { KPI_RATING_CRITERIA } from '@/constants';

import { convertDateToStartOfDayTimestampByTimezone } from '@/helpers/date/date';
import { convertFilterToQuery } from '@/helpers/entities/shared/query';
import { convertMetricValueToString } from '@/helpers/entities/metric/list';
import { isCustomCriteria } from '@/helpers/entities/metric/form';

import { widgetFetchQueryMixin } from '@/mixins/widget/fetch-query';
import { widgetFilterSelectMixin } from '@/mixins/widget/filter-select';
import { metricsIntervalFilterMixin } from '@/mixins/widget/metrics/interval';
import { widgetPeriodicRefreshMixin } from '@/mixins/widget/periodic-refresh';
import { entitiesGroupMetricsMixin } from '@/mixins/entities/group-metrics';

import CAdvancedDataTable from '@/components/common/table/c-advanced-data-table.vue';
import CProgressOverlay from '@/components/common/overlay/c-progress-overlay.vue';

import KpiWidgetFilters from '../../partials/kpi-widget-filters.vue';

const { mapActions } = createNamespacedHelpers('ratingSettings');

export default {
  inject: ['$system'],
  components: {
    CProgressOverlay,
    CAdvancedDataTable,
    KpiWidgetFilters,
  },
  mixins: [
    widgetFetchQueryMixin,
    widgetFilterSelectMixin,
    metricsIntervalFilterMixin,
    widgetPeriodicRefreshMixin,
    entitiesGroupMetricsMixin,
  ],
  props: {
    widget: {
      type: Object,
      required: true,
    },
    tabId: {
      type: String,
      default: '',
    },
    showInterval: {
      type: Boolean,
      default: false,
    },
    showFilter: {
      type: Boolean,
      default: false,
    },
    filterAddable: {
      type: Boolean,
      default: false,
    },
    filterEditable: {
      type: Boolean,
      default: false,
    },
    filterDisabled: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      mainRatingSettingsPending: false,
      mainRatingSettings: [],
    };
  },
  computed: {
    mainParameter() {
      return this.widget.parameters?.mainParameter ?? {};
    },

    isCustomCriteria() {
      return isCustomCriteria(this.mainParameter.criteria);
    },

    firstColumnText() {
      const criteriaObject = find(this.mainRatingSettings, {
        id: this.mainParameter.criteria,
      });

      const labelsMap = {
        [KPI_RATING_CRITERIA.user]: this.$t('common.username'),
        [KPI_RATING_CRITERIA.role]: this.$tc('common.role'),
        [KPI_RATING_CRITERIA.category]: this.$t('common.category'),
        [KPI_RATING_CRITERIA.impactLevel]: this.$t('common.impactLevel'),
      };

      return this.mainParameter.columnName || labelsMap[criteriaObject?.label] || '';
    },

    headers() {
      if (this.mainRatingSettingsPending) {
        return [];
      }

      return [
        {
          text: this.firstColumnText,
          value: 'title',
          sortable: false,
        },

        ...this.widget.parameters.widgetColumns.map(({ metric }) => {
          const alarmKey = `alarm.metrics.${metric}`;

          return {
            text: this.$te(alarmKey) ? this.$t(alarmKey) : this.$t(`user.metrics.${metric}`),
            value: metric,
            sortable: false,
          };
        }),
      ];
    },

    preparedGroupMetrics() {
      return this.groupMetrics.map(({ title, data = [] }) => {
        const preparedMetrics = Object.entries(data)
          .reduce((acc, [metric, value]) => {
            acc[metric] = value.reduce((secondAcc, item) => {
              const preparedValue = convertMetricValueToString(item.value, metric);

              return secondAcc + (item.title ? `${item.title}: ${preparedValue}\n` : preparedValue);
            }, '');

            return acc;
          }, {});

        return {
          title,

          ...preparedMetrics,
        };
      });
    },

    minAvailableDate() {
      const { min_date: minDate } = this.groupMetricsMeta;

      return minDate
        ? convertDateToStartOfDayTimestampByTimezone(minDate, this.$system.timezone)
        : null;
    },
  },
  watch: {
    minAvailableDate() {
      const { from } = this.getIntervalQuery();

      if (from < this.minAvailableDate) {
        this.query = {
          ...this.query,
          interval: {
            from: this.minAvailableDate,
            to: this.query.interval.to,
          },
        };
      }
    },
  },
  mounted() {
    this.fetchMainRatingSettingsList();
  },
  methods: {
    ...mapActions({ fetchRatingSettingsWithoutStore: 'fetchListWithoutStore' }),

    getQuery() {
      return {
        ...this.getIntervalQuery(),
        ...pick(this.query, ['parameters', 'criteria', 'entity_patterns', 'limit', 'page']),
        widget_filters: convertFilterToQuery(this.query.filter),
      };
    },

    async fetchMainRatingSettingsList() {
      this.mainRatingSettingsPending = true;

      const { data: mainRatingSettings = [] } = await this.fetchRatingSettingsWithoutStore({
        params: {
          type: this.type,
          main: true,
          paginate: false,
        },
      });

      this.mainRatingSettings = mainRatingSettings;
      this.mainRatingSettingsPending = false;
    },

    fetchList() {
      return this.fetchGroupMetricsList({
        widgetId: this.widget._id,
        params: this.getQuery(),
      });
    },
  },
};
</script>
