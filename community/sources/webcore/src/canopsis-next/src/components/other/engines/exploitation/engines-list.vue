<template lang="pug">
  v-layout(row, justify-center)
    network-graph(
      :loading="loading",
      :nodes="nodes",
      @node-over="nodeOverHandler",
      @node-out="nodeOutHandler"
    )
      template(slot="node", slot-scope="{ node }") {{ getNodeName(node) }}
    v-menu(
      v-if="activeEngine",
      :value="true",
      :position-x="position.pageX",
      :position-y="position.pageY",
      fixed
    )
      engine-card(
        :title="$t(`engines.${activeEngine.name}.title`)",
        :description="$t(`engines.${activeEngine.name}.description`)",
        :color="activeEngine.color"
      )
</template>

<script>
import { CAT_ENGINES, ENGINES_NAMES, ENGINES_NAMES_TO_QUEUE_NAMES } from '@/constants';
import { COLORS } from '@/config';

import NetworkGraph from './partials/network-graph.vue';
import EngineCard from './partials/engine-card.vue';

export default {
  components: {
    EngineCard,
    NetworkGraph,
  },
  props: {
    loading: {
      type: Boolean,
      default: false,
    },
    engines: {
      type: Array,
      default: () => [],
    },
  },
  data() {
    return {
      activeEngine: null,
      position: null,
    };
  },
  computed: {
    nodes() {
      const enginesByName = this.engines.reduce((acc, engine) => {
        acc[engine.name] = {
          name: engine.name,
          data: engine,
          color: CAT_ENGINES.includes(engine.name) ? COLORS.secondary : COLORS.primary,
          dependencies: [],
        };

        return acc;
      }, {});

      this.engines.forEach((engine) => {
        const inputName = ENGINES_NAMES_TO_QUEUE_NAMES[engine.input_queue];
        const outputName = ENGINES_NAMES_TO_QUEUE_NAMES[engine.output_queue];

        const currentNode = enginesByName[engine.name];
        const outputNode = enginesByName[outputName];
        const inputNode = enginesByName[inputName];
        const currentNodeDependsOnInput = currentNode.dependencies.includes(inputNode.name);

        if (outputNode && outputName !== engine.name) {
          outputNode.dependencies.push(engine.name);
        }

        if (inputName !== engine.name && inputNode && !currentNodeDependsOnInput) {
          currentNode.dependencies.push(inputNode.name);
        }

        if (ENGINES_NAMES.fifo === currentNode.name) {
          currentNode.dependencies.push(ENGINES_NAMES.event);
        }
      });

      const nodes = Object.values(enginesByName);

      nodes.push({
        name: ENGINES_NAMES.event,
        dependencies: [],
        color: COLORS.primary,
      });

      return nodes;
    },
  },
  methods: {
    nodeOverHandler(node, event) {
      const { x, y, width } = event.target.getBoundingClientRect();

      this.position = {
        pageX: x + width,
        pageY: y,
      };
      this.activeEngine = node;
    },

    nodeOutHandler() {
      this.position = null;
      this.activeEngine = null;
    },

    getNodeName(node) {
      const translateKey = `engines.${node.name}.title`;

      return this.$te(translateKey) ? this.$t(translateKey) : node.name;
    },
  },
};
</script>
