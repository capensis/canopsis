<template lang="pug">
  div
    div.canvas-wrapper(ref="canvasWrapper")
    div.v-tooltip__content.menuable__content__active(ref="tooltip")
</template>

<script>
import { minBy } from 'lodash';
import cytoscape from 'cytoscape';
import cytoscapeNodeHtmlLabel from 'cytoscape-node-html-label';
import cytoscapeDagre from 'cytoscape-dagre';

import { COLORS } from '@/config';
import {
  HEALTHCHECK_SERVICES_NAMES,
  HEALTHCHECK_ENGINES_NAMES,
  HEALTHCHECK_NETWORK_GRAPH_OPTIONS,
  HEALTHCHECK_SERVICES_RENDERED_POSITIONS_DIFF_FACTORS,
} from '@/constants';

import { getNodeColor, getNodeRenderedPositionDiff } from '@/helpers/charts/cytoscape';

cytoscapeNodeHtmlLabel(cytoscape);
cytoscape.use(cytoscapeDagre);

export default {
  props: {
    services: {
      type: Array,
      default: () => [],
    },
    engines: {
      type: Object,
      default: () => ({}),
    },
    hasInvalidEnginesOrder: {
      type: Boolean,
      default: false,
    },
  },
  computed: {
    servicesNodes() {
      return [
        ...this.services.map(node => ({
          classes: ['service-title--bottom'],
          data: {
            id: node.name,
            color: getNodeColor(node),
          },
        })),

        {
          classes: ['service-node--without-node'],
          data: { id: HEALTHCHECK_SERVICES_NAMES.events },
        },
        {
          classes: ['service-node--without-node'],
          data: { id: HEALTHCHECK_SERVICES_NAMES.healthcheck },
        },
        {
          data: { id: HEALTHCHECK_SERVICES_NAMES.api, color: COLORS.primary },
        },
        {
          locked: true,
          classes: ['service-node--without-node'],
          data: { id: HEALTHCHECK_SERVICES_NAMES.enginesChain },
        },
      ];
    },

    servicesEdges() {
      return [
        {
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.mongo,
            target: HEALTHCHECK_SERVICES_NAMES.api,
            color: COLORS.healthcheck.edgeGray,
            label: 'Status check',
          },
        },
        {
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.events,
            target: HEALTHCHECK_SERVICES_NAMES.rabbit,
            color: COLORS.healthcheck.edgeBlack,
          },
        },
        {
          classes: ['service-edge__vertical'],
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.rabbit,
            target: HEALTHCHECK_SERVICES_NAMES.api,
            color: COLORS.healthcheck.edgeGray,
            label: 'Status check',
          },
        },
        {
          classes: ['service-edge--multiline'],
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.redis,
            target: HEALTHCHECK_SERVICES_NAMES.api,
            color: COLORS.healthcheck.edgeGray,
            label: 'FIFO data\nRedis check',
          },
        },
        {
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.api,
            target: HEALTHCHECK_SERVICES_NAMES.healthcheck,
            color: COLORS.healthcheck.edgeGray,
          },
        },
        {
          data: {
            source: HEALTHCHECK_SERVICES_NAMES.rabbit,
            target: HEALTHCHECK_ENGINES_NAMES.fifo,
            color: COLORS.healthcheck.edgeBlack,
          },
        },
        {
          classes: ['service-edge--multiline'],
          data: {
            source: HEALTHCHECK_ENGINES_NAMES.fifo,
            target: HEALTHCHECK_SERVICES_NAMES.redis,
            color: COLORS.healthcheck.edgeGray,
            label: 'RabbitMQ status\nIncomming flow KPIs',
          },
        },
      ];
    },

    servicesElements() {
      return [
        ...this.servicesNodes.map(node => ({ group: 'nodes', ...node })),
        ...this.servicesEdges.map(edge => ({ group: 'edges', ...edge })),
      ];
    },

    enginesNodes() {
      return this.engines.nodes.map(node => ({
        classes: ['engine'],
        data: { ...node, id: node.name, color: getNodeColor(node) },
      }));
    },

    enginesEdges() {
      return this.engines.edges.map(edge =>
        ({ data: { source: edge.from, target: edge.to, color: COLORS.healthcheck.edgeBlack } }));
    },

    enginesElements() {
      return [
        ...this.enginesNodes.map(node => ({ group: 'nodes', ...node })),
        ...this.enginesEdges.map(edge => ({ group: 'edges', ...edge })),
      ];
    },

    nodeHtmlLabels() {
      return [
        {
          query: 'node',
          valign: 'top',
          halign: 'right',
          valignBox: 'top',
          halignBox: 'right',
          tpl: data => `<div class="subheading">${data.id}</div>`,
        },
        {
          query: '.service-title--bottom',
          valign: 'bottom',
          halign: 'center',
          valignBox: 'bottom',
          halignBox: 'center',
          tpl: data => `<div class="subheading">${data.id}</div>`,
        },
        {
          query: '.service-node--without-node',
          valign: 'center',
          halign: 'center',
          tpl: data => `<div class="headline">${data.id}</div>`,
        },
        {
          query: `node[id="${HEALTHCHECK_SERVICES_NAMES.events}"]`,
          halign: 'left',
          tpl: data => `<div class="headline">${data.id}</div>`,
        },
        {
          query: '.engine',
          valign: 'center',
          halign: 'right',
          valignBox: 'center',
          halignBox: 'right',
          tpl: this.getEngineHtmlLabel,
        },
        {
          query: `node[id="${HEALTHCHECK_SERVICES_NAMES.enginesChain}"]`,
          valign: 'center',
          halign: 'center',
          tpl: this.getEnginesChainHtmlLabel,
        },
      ];
    },

    cytoscapeStyleOption() {
      return [
        {
          selector: 'core',
          style: {
            'active-bg-size': 0,
          },
        },
        {
          selector: 'node',
          style: {
            width: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.nodeSize,
            height: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.nodeSize,
            'border-width': 3,
          },
        },
        {
          selector: `node[id="${HEALTHCHECK_SERVICES_NAMES.enginesChain}"]`,
          style: {
            events: 'no',
          },
        },
        {
          selector: 'node[color]',
          style: {
            'background-color': 'data(color)',
            'border-color': 'data(color)',
          },
        },
        {
          selector: 'edge',
          style: {
            width: 2,
            'curve-style': 'bezier',
            'target-arrow-shape': 'triangle',
            'target-arrow-color': 'data(color)',
            'line-color': 'data(color)',
          },
        },
        {
          selector: 'edge[label]',
          style: {
            label: 'data(label)',
            color: 'gray',
            'font-size': '14px',
            'text-wrap': 'wrap',
            'text-margin-y': -10,
          },
        },
        {
          selector: '.service-node--without-node',
          style: {
            'background-opacity': 0,
            'border-width': 0,
          },
        },
        {
          selector: '.service-edge__vertical',
          style: {
            'text-rotation': '90deg',
            'text-margin-x': 10,
            'text-margin-y': 0,
          },
        },
        {
          selector: '.service-edge--multiline',
          style: {
            'text-margin-y': 0,
            'line-height': 1.5,
          },
        },
      ];
    },

    cytoscapeOptions() {
      const { servicesElements } = this;

      return {
        container: this.$refs.canvasWrapper,
        elements: this.enginesElements,
        style: this.cytoscapeStyleOption,
        wheelSensitivity: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.wheelSensitivity,
        minZoom: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.minZoom,
        maxZoom: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.maxZoom,
        layout: {
          name: 'dagre',
          direction: true,
          spacingFactor: HEALTHCHECK_NETWORK_GRAPH_OPTIONS.spacingFactor,
        },
        /**
         * Here we are adding the service elements on the left side of fifo-engine
         */
        ready() {
          const zoom = this.zoom();
          const [fifoNode] = this.nodes(`[id="${HEALTHCHECK_ENGINES_NAMES.fifo}"]`);
          const positionWithMinY = fifoNode
            ? fifoNode.renderedPosition()
            : minBy(this.nodes().renderedPosition(), 'y');


          if (!positionWithMinY) {
            return;
          }

          const preparedElements = servicesElements.map((element) => {
            if (element.group !== 'nodes') {
              return element;
            }

            const itemDiffFactors = HEALTHCHECK_SERVICES_RENDERED_POSITIONS_DIFF_FACTORS[element.data.id];

            if (!itemDiffFactors) {
              return element;
            }

            return {
              ...element,

              renderedPosition: {
                x: (getNodeRenderedPositionDiff(itemDiffFactors.x) * zoom) + positionWithMinY.x,
                y: (getNodeRenderedPositionDiff(itemDiffFactors.y) * zoom) + positionWithMinY.y,
              },
            };
          });

          this.add(preparedElements);
          this.fit(this.nodes(), HEALTHCHECK_NETWORK_GRAPH_OPTIONS.fitPadding);
        },
      };
    },
  },
  mounted() {
    this.$cy = cytoscape(this.cytoscapeOptions);

    this.$cy.nodeHtmlLabel(this.nodeHtmlLabels);
    this.$cy.bind('mouseover', 'node', this.nodeMouseoverHandler);
    this.$cy.bind('mouseout', 'node', this.nodeMouseoutHandler);
    this.$cy.bind('tap', 'node', this.nodeTapHandler);
  },
  beforeDestroy() {
    this.$cy.destroy();
  },
  methods: {
    /**
     * Get content for the tooltip by node data
     *
     * @param {Object} data
     * @return {string}
     */
    getTooltipContent(data) {
      return `<div>${data.id}</div>`; // TODO: add correct tooltip
    },

    /**
     * Show tooltip with special position and content
     *
     * @param {{ x: number, y: number }} renderedPosition
     * @param {Object} data
     * @param {number} [zoom = 1]
     */
    showTooltip({ renderedPosition, data, zoom = 1 }) {
      const { tooltip: tooltipEl } = this.$refs;
      const { x } = renderedPosition;
      const y = renderedPosition.y - ((HEALTHCHECK_NETWORK_GRAPH_OPTIONS.nodeSize / 2) * zoom);

      tooltipEl.innerHTML = this.getTooltipContent(data);
      tooltipEl.style.left = `${Math.round(x)}px`;
      tooltipEl.style.top = `${Math.round(y)}px`;
      tooltipEl.style.opacity = 1;
    },

    /**
     * Hide tooltip
     */
    hideTooltip() {
      this.$refs.tooltip.style.opacity = 0;
    },

    /**
     * Get html label for engines chain service node
     *
     * @param {string} id
     * @return {string}
     */
    getEnginesChainHtmlLabel({ id }) {
      const nameSpan = `<span class="headline">${id}</span>`;
      let wrapperDivClass = '';
      let icon = '';

      if (this.hasInvalidEnginesOrder) {
        wrapperDivClass = 'v-chip theme--light px-3 py-1 red white--text cursor-pointer';
        icon = '<i class="v-icon material-icons theme--dark ml-2">warning</i>';
      }

      return `<div class="${wrapperDivClass}">${nameSpan}${icon}</div>`;
    },

    /**
     * Get html label for engine node
     *
     * @param {string} id
     * @param {number} time
     * @param {number} instances
     * @param {number} minInstances
     * @param {number} queueLength
     * @param {number} maxQueueLength
     * @return {string}
     */
    getEngineHtmlLabel({
      id,
      time,
      instances,
      min_instances: minInstances,
      queue_length: queueLength,
      max_queue_length: maxQueueLength,
    }) {
      const nameDiv = `<div class="subheading">${id}</div>`;
      const getInfoDiv = (message, hasError) =>
        `<div class="body-1 grey--text darken-3 ${hasError ? 'error--text' : ''}">${message}</div>`;

      const firstInfoDiv = HEALTHCHECK_ENGINES_NAMES.fifo === id
        ? getInfoDiv(this.$options.filters.date(time, 'long', true))
        : getInfoDiv(`Queue length ${queueLength}/${maxQueueLength}`, queueLength >= maxQueueLength);

      const secondInfoDiv = getInfoDiv(`Instances ${instances}/${minInstances}`, instances < minInstances);

      return `<div class="ml-1">${nameDiv}${firstInfoDiv}${secondInfoDiv}</div>`;
    },

    /**
     * Handler for the 'tap' event on node for cytoscape
     *
     * @param {Object} event
     */
    nodeTapHandler(event) {
      this.$emit('click', event);
    },

    /**
     * Handler for the 'mouseover' event on node for cytoscape
     *
     * @param {Object} target
     * @param {Object} cy
     */
    nodeMouseoverHandler({ target, cy }) {
      target.style('border-color', COLORS.healthcheck.edgeGray);

      this.showTooltip({
        renderedPosition: target.renderedPosition(),
        data: target.data(),
        zoom: cy.zoom(),
      });

      this.$refs.canvasWrapper.classList.add('canvas-wrapper--pointer');
    },

    /**
     * Handler for the 'mouseout' event on node for cytoscape
     *
     * @param {Object} target
     */
    nodeMouseoutHandler({ target }) {
      target.style('border-color', target.data('color'));

      this.hideTooltip();
      this.$refs.canvasWrapper.classList.remove('canvas-wrapper--pointer');
    },
  },
};
</script>

<style lang="scss" scoped>
.canvas-wrapper {
  position: relative;
  width: 100%;
  height: 100vh;
  background: white;
  cursor: grabbing;

  &--pointer {
    cursor: pointer;
  }
}

.v-tooltip__content {
  position: absolute;
  opacity: 0;
  transition: all .2s linear;
  transform: translate(-50%, 50%);
}
</style>
