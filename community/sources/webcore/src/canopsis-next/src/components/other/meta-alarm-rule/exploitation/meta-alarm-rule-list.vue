<template lang="pug">
  c-advanced-data-table.white(
    :items="rules",
    :headers="headers",
    :loading="pending",
    :is-expandable-item="hasRulePatterns",
    select-all,
    expand
  )
    template(slot="toolbar", slot-scope="props")
      v-flex(v-show="hasDeleteAnyMetaAlarmRuleAccess && props.selected.length", xs4)
        v-btn(icon, @click="$emit('remove-selected', props.selected)")
          v-icon(color="error") delete
    template(slot="auto_resolve", slot-scope="props")
      c-enabled(:value="props.item.auto_resolve")
    template(slot="config.threshold_rate", slot-scope="props") {{ props.item | getThresholdRatePercent }}
    template(slot="config.threshold_count", slot-scope="props") {{ props.item | get('config.threshold_count') }}
    template(slot="config.time_interval", slot-scope="props") {{ props.item | getStringTimeInterval }}
    template(slot="actions", slot-scope="props")
      v-layout(row)
        c-action-btn(
          v-if="hasUpdateAnyMetaAlarmRuleAccess",
          type="edit",
          @click="$emit('edit', props.item)"
        )
        c-action-btn(
          v-if="hasCreateAnyMetaAlarmRuleAccess",
          type="duplicate",
          @click="$emit('duplicate', props.item)"
        )
        c-action-btn(
          v-if="hasDeleteAnyMetaAlarmRuleAccess",
          type="delete",
          @click="$emit('remove', props.item._id)"
        )
    template(
      v-if="hasRulePatterns(props.item)",
      slot="expand",
      slot-scope="props"
    )
      meta-alarm-rule-list-expand-panel(:meta-alarm-rule="props.item")
</template>

<script>
import { get } from 'lodash';

import rightsTechnicalExploitationMetaAlarmRuleMixin from '@/mixins/rights/technical/exploitation/meta-alarm-rule';

import { META_ALARMS_RULE_TYPES } from '@/constants';

import percentage from '@/filters/percentage';

import { convertDurationToIntervalObject } from '@/helpers/date/date';

import MetaAlarmRuleListExpandPanel from './partials/meta-alarm-rule-list-expand-panel.vue';

export default {
  components: {
    MetaAlarmRuleListExpandPanel,
  },
  filters: {
    getStringTimeInterval({ config }) {
      const timeInterval = get(config, 'time_interval');

      if (timeInterval) {
        const { unit, interval } = convertDurationToIntervalObject(config.time_interval);

        return `${interval}${unit}`;
      }

      return '';
    },
    getThresholdRatePercent({ config }) {
      const thresholdRate = get(config, 'threshold_rate');

      return thresholdRate && percentage(thresholdRate);
    },
  },
  mixins: [
    rightsTechnicalExploitationMetaAlarmRuleMixin,
  ],
  props: {
    rules: {
      type: Array,
      default: () => [],
    },
    pending: {
      type: Boolean,
      default: true,
    },
  },
  computed: {
    headers() {
      return [
        {
          text: this.$t('metaAlarmRule.id'),
          value: '_id',
        },
        {
          text: this.$t('common.name'),
          value: 'name',
        },
        {
          text: this.$t('metaAlarmRule.type'),
          value: 'type',
        },
        {
          text: this.$t('metaAlarmRule.fields.autoResolve'),
          value: 'auto_resolve',
        },
        {
          text: this.$t('metaAlarmRule.fields.thresholdRate'),
          value: 'config.threshold_rate',
        },
        {
          text: this.$t('metaAlarmRule.fields.thresholdCount'),
          value: 'config.threshold_count',
        },
        {
          text: this.$t('metaAlarmRule.fields.timeInterval'),
          value: 'config.time_interval',
        },
        {
          text: this.$t('metaAlarmRule.actions'),
          value: 'actions',
          sortable: false,
        },
      ];
    },
  },
  methods: {
    hasRulePatterns({ type }) {
      return type === META_ALARMS_RULE_TYPES.attribute || type === META_ALARMS_RULE_TYPES.complex;
    },
  },
};
</script>

