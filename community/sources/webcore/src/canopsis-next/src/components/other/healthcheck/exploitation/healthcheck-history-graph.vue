<template lang="pug">
  div.healthcheck-history(@touchend.stop)
    v-layout.ml-4.mb-4(align-center)
      c-quick-date-interval-field(
        :interval="pagination.interval",
        :min="deletedBefore",
        @input="updateInterval"
      )
    div.healthcheck-history__graph
      limited-time-line-chart.text--primary(ref="chart", :datasets="datasets", :options="historyChartOptions")
        v-layout.mt-4(slot="actions", slot-scope="props", justify-end)
          v-btn.ma-0(color="primary", @click="exportChart(props.chart)")
            v-icon(left) file_download
            span {{ $t('common.downloadAsPng') }}
          div.healthcheck-history__zoom
            v-btn(color="white", fab, small, @click="zoomIn(props.chart)")
              v-icon add
            v-btn(color="white", fab, small, @click="zoomOut(props.chart)")
              v-icon remove
</template>

<script>
import { debounce } from 'lodash';
import {
  DATETIME_FORMATS,
  DATETIME_INTERVAL_TYPES,
  HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR,
  MESSAGE_STATS_INTERVALS,
  QUICK_RANGES,
  TIME_UNITS,
} from '@/constants';
import { COLORS, HEALTHCHECK_HISTORY_FILENAME_PREFIX } from '@/config';

import { convertDateToStartOfDayMoment, formatDate } from '@/helpers/date/date';
import { dateParse } from '@/helpers/date/date-intervals';
import { convertUnit } from '@/helpers/date/duration';
import { colorToRgba } from '@/helpers/color';
import { saveFile } from '@/helpers/file/files';
import { canvasToBlob } from '@/helpers/charts/canvas';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';
import { localQueryMixin } from '@/mixins/query-local/query';

const LimitedTimeLineChart = () => import(/* webpackChunkName: "Charts" */ '@/components/common/chart/limited-time-line-chart.vue');

export default {
  components: { LimitedTimeLineChart },
  mixins: [entitiesMessageRateStatsMixin, localQueryMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      messagesStats: [],
      deletedBefore: 0,
      query: {
        interval: {
          from: QUICK_RANGES.last30Days.start,
          to: QUICK_RANGES.last30Days.stop,
        },
      },
    };
  },
  computed: {
    interval() {
      return {
        from: dateParse(
          this.pagination.interval.from,
          DATETIME_INTERVAL_TYPES.start,
          DATETIME_FORMATS.datePicker,
        ).unix(),
        to: dateParse(
          this.pagination.interval.to,
          DATETIME_INTERVAL_TYPES.stop,
          DATETIME_FORMATS.datePicker,
        ).unix(),
      };
    },

    suggestedMax() {
      return Math.max.apply(null, this.messagesStats.map(({ rate }) => rate))
        * HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR;
    },

    datasets() {
      return [{
        backgroundColor: colorToRgba(COLORS.healthcheck.edgeGray, 0.7),
        fill: true,
        data: this.messagesStats.map(({ time, rate }) => ({
          x: time * 1000,
          y: rate,
        })),
      }];
    },

    historyChartOptions() {
      return {
        animation: false,
        scales: {
          x: {
            min: this.interval.from * 1000,
            max: this.interval.to * 1000,
            time: {
              stepSize: 2,
            },
          },
          y: {
            suggestedMax: this.suggestedMax,
          },
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: tooltip => `${tooltip.formattedValue} ${this.$t('healthcheck.messagesPerHour')}`,
            },
          },
          limit: {
            enabled: true,
            scaleID: 'x',
            value: this.maxQueueLength,
            backgroundColor: COLORS.healthcheck.error,
            borderWidth: 1,
          },
          zoom: {
            limits: {
              x: {
                min: this.deletedBefore * 1000,
                max: Date.now(),
              },
            },
            pan: {
              enabled: true,
              mode: 'x',
              threshold: 5,
              onPanComplete: this.updateChartInterval,
            },
            zoom: {
              mode: 'x',
              wheel: {
                enabled: true,
                speed: 0.1,
              },
              pinch: {
                enabled: true,
              },
              drag: {
                enabled: true,
                modifierKey: 'ctrl',
              },
              onZoom: this.updateChartInterval,
            },
          },
        },
      };
    },
  },
  created() {
    this.updateIntervalDebounced = debounce(this.updateInterval, 300);
  },
  mounted() {
    this.fetchList();
  },
  methods: {
    customQueryCondition(query, oldQuery) {
      const isFromChanged = query.interval.from !== oldQuery.interval.from;
      const isFromEqualDeletedBefore = query.interval.from === this.deletedBefore;
      const isToChanged = query.interval.to !== oldQuery.interval.to;

      return (isFromChanged && !isFromEqualDeletedBefore) || isToChanged;
    },

    async exportChart(chart) {
      try {
        const fromTime = formatDate(this.interval.from, DATETIME_FORMATS.long);
        const toTime = formatDate(this.interval.to, DATETIME_FORMATS.long);

        const chartBlob = await canvasToBlob(chart.canvas);

        await saveFile(chartBlob, `${HEALTHCHECK_HISTORY_FILENAME_PREFIX}${fromTime}-${toTime}`);
      } catch (err) {
        this.$popups.error({ text: err.message || this.$t('errors.default') });
      }
    },

    zoomOut(chart) {
      chart.zoom({ x: 0.9 });
    },

    zoomIn(chart) {
      chart.zoom({ x: 1.1 });
    },

    updateChartInterval({ chart }) {
      const { min, max } = chart.scales.x;

      this.updateIntervalDebounced({
        from: Math.floor(min / 1000),
        to: Math.ceil(max / 1000),
      });
    },

    updateInterval(interval) {
      this.query = {
        ...this.query,
        interval,
      };
    },

    async fetchList() {
      const offsetForSwipe = Math.round((this.interval.to - this.interval.from) / 2);
      const from = this.interval.from - offsetForSwipe;
      const to = this.interval.to + offsetForSwipe;
      const offsetDays = convertUnit(to - from, TIME_UNITS.second, TIME_UNITS.day);
      const interval = offsetDays > 1
        ? MESSAGE_STATS_INTERVALS.hour
        : MESSAGE_STATS_INTERVALS.minute;

      const { data: messagesStats, meta } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from,
          to,
          interval,
        },
      });

      this.messagesStats = messagesStats;

      if (meta.deleted_before) {
        this.deletedBefore = convertDateToStartOfDayMoment(meta.deleted_before).unix();

        if (this.interval.from < this.deletedBefore) {
          this.updateInterval({
            ...this.query.interval,
            from: this.deletedBefore,
          });
        }
      }
    },
  },
};
</script>

<style lang="scss" scoped>
.healthcheck-history {
  &__graph {
    position: relative;
  }

  &__zoom {
    position: absolute;
    top: 10px;
    right: 10px;
  }
}
</style>
