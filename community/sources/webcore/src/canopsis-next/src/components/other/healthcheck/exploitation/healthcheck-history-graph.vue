<template lang="pug">
  div.healthcheck-history-graph(@touchend.stop)
    limited-time-line-chart.text--primary(
      :datasets="datasets",
      :options="historyChartOptions",
      :unit="$t('healthcheck.messagesPerHour')"
    )
      div.healthcheck-history-graph__zoom(slot="actions", slot-scope="props")
        v-layout(row)
          v-btn(color="white", fab, small, @click="zoomIn(props.chart)")
            v-icon add
          v-btn(color="white", fab, small, @click="zoomOut(props.chart)")
            v-icon remove
</template>

<script>
import { debounce } from 'lodash';
import {
  DATETIME_FORMATS,
  DATETIME_INTERVAL_TYPES,
  MESSAGE_STATS_INTERVALS,
  QUICK_RANGES,
  TIME_UNITS,
} from '@/constants';
import { COLORS } from '@/config';

import { convertDateToTimestampByTimezone } from '@/helpers/date/date';
import { dateParse } from '@/helpers/date/date-intervals';
import { convertUnit, fromSeconds } from '@/helpers/date/duration';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';
import { localQueryMixin } from '@/mixins/query-local/query';

import LimitedTimeLineChart from '@/components/common/chart/limited-time-line-chart.vue';

export default {
  inject: ['$system'],
  components: { LimitedTimeLineChart },
  mixins: [entitiesMessageRateStatsMixin, localQueryMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      pending: false,
      messagesStats: [],
      deletedBefore: 0,
      query: {
        interval: {
          from: QUICK_RANGES.last1Year.start,
          to: QUICK_RANGES.last1Year.stop,
        },
      },
    };
  },
  computed: {
    interval() {
      const from = convertDateToTimestampByTimezone(dateParse(
        this.pagination.interval.from,
        DATETIME_INTERVAL_TYPES.start,
        DATETIME_FORMATS.datePicker,
      ), this.$system.timezone);
      const to = convertDateToTimestampByTimezone(dateParse(
        this.pagination.interval.to,
        DATETIME_INTERVAL_TYPES.stop,
        DATETIME_FORMATS.datePicker,
      ), this.$system.timezone);

      return { from, to };
    },

    datasets() {
      return [{
        backgroundColor: 'rgba(90, 109, 128, 0.7)',
        fill: true,
        data: this.messagesStats.map(({ _id: time, received }) => ({
          x: time * 1000,
          y: received,
        })),
      }];
    },

    historyChartOptions() {
      return {
        animation: false,
        plugins: {
          limit: {
            enabled: true,
            scaleID: 'x',
            value: this.maxQueueLength,
            backgroundColor: COLORS.healthcheck.error,
            borderWidth: 1,
          },
          zoom: {
            limits: {
              x: {
                min: this.deletedBefore * 1000,
                max: Date.now(),
              },
            },
            pan: {
              enabled: true,
              mode: 'x',
              threshold: 5,
              onPanComplete: this.updateChartInterval,
            },
            zoom: {
              mode: 'x',
              wheel: {
                enabled: true,
                speed: 0.1,
              },
              pinch: {
                enabled: true,
              },
              drag: {
                enabled: true,
                modifierKey: 'ctrl',
              },
              onZoom: this.updateChartInterval,
            },
          },
        },
      };
    },
  },
  created() {
    this.updateIntervalDebounced = debounce(this.updateInterval, 300);
  },
  mounted() {
    this.fetchList();
  },
  methods: {
    zoom(scale) {
      const zoomOffset = (this.interval.from - this.interval.to) * (scale - 1);

      this.updateInterval({
        from: Math.floor(this.interval.from + zoomOffset),
        to: Math.ceil(this.interval.to - zoomOffset),
      });
    },

    zoomOut(chart) {
      chart.zoom({ x: 0.9 });
    },

    zoomIn(chart) {
      chart.zoom({ x: 1.1 });
    },

    updateChartInterval({ chart }) {
      const { min, max } = chart.scales.x;

      this.updateIntervalDebounced({
        from: Math.round(min / 1000),
        to: Math.round(max / 1000),
      });
    },

    updateInterval(interval) {
      this.query = {
        ...this.query,
        interval,
      };
    },

    async fetchList() {
      this.pending = true;

      const offsetSeconds = this.interval.to - this.interval.from;
      const offsetDays = convertUnit(offsetSeconds, TIME_UNITS.second, TIME_UNITS.day);
      const interval = offsetDays > 1 ? MESSAGE_STATS_INTERVALS.hour : MESSAGE_STATS_INTERVALS.minute;
      const limit = Math.floor(fromSeconds(offsetSeconds, TIME_UNITS[interval]));

      const { data: messagesStats, meta } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from: this.interval.from,
          to: this.interval.to,
          interval,
          limit,
        },
      });

      this.messagesStats = messagesStats;
      this.deletedBefore = meta.deleted_before;
      this.pending = false;
    },
  },
};
</script>

<style lang="scss" scoped>
.healthcheck-history-graph {
  position: relative;

  &__zoom {
    position: absolute;
    top: 10px;
    right: 10px;
  }
}
</style>
