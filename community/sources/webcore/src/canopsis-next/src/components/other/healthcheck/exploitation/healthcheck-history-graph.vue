<template lang="pug">
  div.healthcheck-history-graph
    div.healthcheck-history-graph__zoom
      v-layout(row)
        v-btn(color="white", fab, small, @click="zoomIn")
          v-icon add
        v-btn(color="white", fab, small, @click="zoomOut")
          v-icon remove
    limited-line-chart.text--primary(
      :datasets="datasets",
      :options="historyChartOptions",
      :unit="$t('healthcheck.messagesPerHour')",
      :limit="chartLimit"
    )
</template>

<script>
import { debounce } from 'lodash';
import {
  DATETIME_FORMATS,
  DATETIME_INTERVAL_TYPES,
  MESSAGE_STATS_INTERVALS,
  QUICK_RANGES,
  TIME_UNITS,
} from '@/constants';
import { COLORS } from '@/config';

import { convertDateToTimestampByTimezone } from '@/helpers/date/date';
import { dateParse } from '@/helpers/date/date-intervals';
import { convertUnit, fromSeconds } from '@/helpers/date/duration';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';
import { localQueryMixin } from '@/mixins/query-local/query';

import LimitedLineChart from '@/components/common/chart/limited-line-chart.vue';

export default {
  inject: ['$system'],
  components: { LimitedLineChart },
  mixins: [entitiesMessageRateStatsMixin, localQueryMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      pending: false,
      messagesStats: [],
      query: {
        interval: {
          from: QUICK_RANGES.last1Year.start,
          to: QUICK_RANGES.last1Year.stop,
        },
      },
    };
  },
  computed: {
    chartLimit() {
      return {
        value: 10,
        backgroundColor: COLORS.healthcheck.error,
        borderWidth: 1,
      };
    },

    interval() {
      const from = convertDateToTimestampByTimezone(dateParse(
        this.pagination.interval.from,
        DATETIME_INTERVAL_TYPES.start,
        DATETIME_FORMATS.datePicker,
      ), this.$system.timezone);
      const to = convertDateToTimestampByTimezone(dateParse(
        this.pagination.interval.to,
        DATETIME_INTERVAL_TYPES.stop,
        DATETIME_FORMATS.datePicker,
      ), this.$system.timezone);

      return { from, to };
    },

    datasets() {
      return [{
        backgroundColor: 'rgba(90, 109, 128, 0.7)',
        data: this.messagesStats.map(({ _id: time, received }) => ({
          x: new Date(time * 1000),
          y: received,
        })),
      }];
    },

    historyChartOptions() {
      return {
        animation: false,
        scales: {
          xAxes: [{
            type: 'time',
            time: {
              tooltipFormat: DATETIME_FORMATS.longWithDayOfWeek,
              // TODO: Should be uncommented after update chart.js
              // displayFormats: {
              //   year: DATETIME_FORMATS.shortWithDayOfWeek,
              //   quarter: DATETIME_FORMATS.shortWithDayOfWeek,
              //   month: DATETIME_FORMATS.shortWithDayOfWeek,
              //   week: DATETIME_FORMATS.shortWithDayOfWeek,
              //   day: DATETIME_FORMATS.shortWithDayOfWeek,
              //   hour: DATETIME_FORMATS.medium,
              //   minute: DATETIME_FORMATS.medium,
              //   second: DATETIME_FORMATS.medium,
              // },
            },
            ticks: {
              min: this.interval.from * 1000, // TODO: Doesn't work
              max: this.interval.to * 1000, // TODO: Doesn't work
              fontSize: 11,
              autoSkip: true,
              autoSkipPadding: 10,
              maxRotation: 0,
              beginAtZero: true, // TODO: Doesn't work
            },
          }],
          yAxes: [{
            ticks: {
              min: 0,
              callback: value => (value >= 1000 ? `${value / 1000} k` : value),
              fontSize: 11,
              beginAtZero: true,
            },
          }],
        },
        plugins: {
          zoom: {
            pan: {
              enabled: true,
              mode: 'x',
              rangeMin: {
                x: 0,
                y: 0,
              },
              rangeMax: {
                x: Date.now(),
                y: null,
              },
              onPanComplete: this.updateChartInterval,
            },
            zoom: {
              enabled: true,
              mode: 'x',
              rangeMin: {
                x: 0,
                y: 0,
              },
              rangeMax: {
                x: Date.now(),
                y: null,
              },
              onZoom: this.updateChartInterval,
            },
          },
        },
      };
    },
  },
  created() {
    this.updateIntervalDebounced = debounce(this.updateInterval, 300);
  },
  mounted() {
    this.fetchList();
  },
  methods: {
    zoom(scale) {
      const zoomOffset = (this.interval.from - this.interval.to) * (scale - 1);

      this.updateInterval({
        from: Math.round(this.interval.from + zoomOffset),
        to: Math.round(this.interval.to - zoomOffset),
      });
    },

    zoomOut() {
      this.zoom(1.1);
    },

    zoomIn() {
      this.zoom(0.9);
    },

    updateChartInterval({ chart }) {
      const { min, max } = chart.scales['x-axis-0'];

      this.updateIntervalDebounced({ from: min / 1000, to: max / 1000 });
    },

    updateInterval(interval) {
      this.query = {
        ...this.query,
        interval,
      };
    },

    async fetchList() {
      this.pending = true;

      const offsetSeconds = this.interval.to - this.interval.from;
      const offsetDays = convertUnit(offsetSeconds, TIME_UNITS.second, TIME_UNITS.day);
      const interval = offsetDays > 1 ? MESSAGE_STATS_INTERVALS.hour : MESSAGE_STATS_INTERVALS.minute;
      const limit = Math.floor(fromSeconds(offsetSeconds, TIME_UNITS[interval]));

      const { data: messagesStats } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from: this.interval.from,
          to: this.interval.to,
          interval,
          limit,
        },
      });

      this.messagesStats = messagesStats;
      this.pending = false;
    },
  },
};
</script>

<style lang="scss" scoped>
.healthcheck-history-graph {
  position: relative;

  &__zoom {
    position: absolute;
    top: 10px;
    right: 10px;
  }
}
</style>
