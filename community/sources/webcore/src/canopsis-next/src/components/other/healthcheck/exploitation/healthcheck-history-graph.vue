<template lang="pug">
  div
    limited-line-chart(
      :datasets="datasets",
      :options="historyChartOptions",
      :unit="$t('healthcheck.messagesPerHour')",
      :limit="chartLimit"
    )
</template>

<script>
import { DATETIME_FORMATS, MESSAGE_STATS_INTERVALS } from '@/constants';
import { COLORS } from '@/config';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';

import LimitedLineChart from '@/components/common/chart/limited-line-chart.vue';


export default {
  components: { LimitedLineChart },
  mixins: [entitiesMessageRateStatsMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      pending: false,
      messagesStats: [],
    };
  },
  computed: {
    chartLimit() {
      return {
        value: this.maxQueueLength,
        backgroundColor: COLORS.healthcheck.error,
        borderWidth: 1,
      };
    },

    datasets() {
      return [{
        backgroundColor: 'rgba(90, 109, 128, 0.7)',
        data: this.messagesStats.map(({ _id: time, received }) => ({
          x: new Date(time * 1000),
          y: received,
        })),
      }];
    },

    historyChartOptions() {
      return {
        scales: {
          xAxes: [{
            type: 'time',
            time: {
              tooltipFormat: DATETIME_FORMATS.longWithDayOfWeek,
              displayFormats: {
                year: DATETIME_FORMATS.shortWithDayOfWeek,
                quarter: DATETIME_FORMATS.shortWithDayOfWeek,
                month: DATETIME_FORMATS.shortWithDayOfWeek,
                week: DATETIME_FORMATS.shortWithDayOfWeek,
                day: DATETIME_FORMATS.shortWithDayOfWeek,
                hour: DATETIME_FORMATS.medium,
                minute: DATETIME_FORMATS.medium,
                second: DATETIME_FORMATS.medium,
              },
            },
            ticks: {
              fontSize: 11,
              autoSkip: true,
              autoSkipPadding: 10,
              maxRotation: 0,
            },
          }],
          yAxes: [{
            ticks: {
              callback: value => (value >= 1000 ? `${value / 1000} k` : value),
              fontSize: 11,
            },
          }],
        },
      };
    },
  },
  mounted() {
    this.fetchStats();
  },
  methods: {
    async fetchStats() {
      this.pending = true;

      const { data: messagesStats } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from: 0,
          to: Date.now(),
          interval: MESSAGE_STATS_INTERVALS.hour,
        },
      });

      this.messagesStats = messagesStats;
      this.pending = false;
    },
  },
};
</script>
