<template lang="pug">
  div(@touchend.stop)
    limited-time-line-chart.text--primary(:datasets="datasets", :options="lastHourChartOptions")
</template>

<script>
import { COLORS } from '@/config';
import {
  DATETIME_FORMATS,
  HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR,
  MESSAGE_STATS_INTERVALS,
  TIME_UNITS,
} from '@/constants';

import { colorToRgba } from '@/helpers/color';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';
import { localQueryMixin } from '@/mixins/query-local/query';

import LimitedTimeLineChart from '@/components/common/chart/limited-time-line-chart.vue';
import { getNowTimestamp, subtractUnitFromDate } from '@/helpers/date/date';

export default {
  inject: ['$system'],
  components: { LimitedTimeLineChart },
  mixins: [entitiesMessageRateStatsMixin, localQueryMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      pending: false,
      messagesStats: [],
    };
  },
  computed: {
    suggestedMax() {
      return Math.max.apply(null, this.messagesStats.map(({ received }) => received))
        * HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR;
    },

    datasets() {
      return [{
        backgroundColor: colorToRgba(COLORS.primary, 0.7),
        fill: true,
        data: this.messagesStats.map(({ time, rate }) => ({
          x: time * 1000,
          y: rate,
        })),
      }];
    },

    lastHourChartOptions() {
      return {
        animation: false,
        scales: {
          x: {
            time: {
              tooltipFormat: DATETIME_FORMATS.timePicker,
              displayFormats: {
                minute: DATETIME_FORMATS.timePicker,
              },
            },
          },
          y: {
            suggestedMax: this.suggestedMax,
          },
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: tooltip => `${tooltip.formattedValue} ${this.$t('healthcheck.messagesPerHour')}`,
            },
          },
          limit: {
            enabled: true,
            scaleID: 'x',
            value: this.maxQueueLength,
            backgroundColor: COLORS.healthcheck.error,
            borderWidth: 1,
          },
        },
      };
    },
  },
  mounted() {
    this.fetchList();

    this.$socket.join('message-rates');
    this.$socket.getRoom('message-rates').addListener((data) => {
      this.messagesStats = data;
    });
  },
  beforeDestroy() {
    this.$socket.leave('message-rates');
  },
  methods: {
    async fetchList() {
      this.pending = true;

      const to = getNowTimestamp();
      const from = subtractUnitFromDate(to, 1, TIME_UNITS.hour);

      const { data: messagesStats } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from,
          to,
          interval: MESSAGE_STATS_INTERVALS.minute,
          limit: 60,
        },
      });

      /**
       * TODO: Should be fixed after backend changes
       */
      this.messagesStats = messagesStats.map(({ _id: time, received: rate }) => ({ time, rate }));

      this.pending = false;
    },
  },
};
</script>
