<template lang="pug">
  div(@touchend.stop)
    limited-time-line-chart.text--primary(:datasets="datasets", :options="lastHourChartOptions")
</template>

<script>
import { COLORS } from '@/config';
import {
  DATETIME_FORMATS,
  HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR,
  MESSAGE_STATS_INTERVALS,
  SOCKET_ROOMS,
  TIME_UNITS,
} from '@/constants';

import { colorToRgba } from '@/helpers/color';

import { entitiesMessageRateStatsMixin } from '@/mixins/entities/message-rate-stats';
import { localQueryMixin } from '@/mixins/query-local/query';

import LimitedTimeLineChart from '@/components/common/chart/limited-time-line-chart.vue';
import { getNowTimestamp, subtractUnitFromDate } from '@/helpers/date/date';

export default {
  inject: ['$system'],
  components: { LimitedTimeLineChart },
  mixins: [entitiesMessageRateStatsMixin, localQueryMixin],
  props: {
    maxQueueLength: {
      type: Number,
      required: true,
    },
  },
  data() {
    return {
      pending: false,
      messagesStats: [],
    };
  },
  computed: {
    suggestedMax() {
      return Math.max.apply(null, this.messagesStats.map(({ rate }) => rate))
        * HEALTHCHECK_HISTORY_GRAPH_RECEIVED_FACTOR;
    },

    datasets() {
      return [{
        backgroundColor: colorToRgba(COLORS.primary, 0.7),
        fill: true,
        data: this.messagesStats.map(({ time, rate }) => ({
          x: time * 1000,
          y: rate,
        })),
      }];
    },

    lastHourChartOptions() {
      return {
        animation: false,
        scales: {
          x: {
            time: {
              tooltipFormat: DATETIME_FORMATS.timePicker,
              displayFormats: {
                minute: DATETIME_FORMATS.timePicker,
              },
            },
          },
          y: {
            suggestedMax: this.suggestedMax,
          },
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: tooltip => `${tooltip.formattedValue} ${this.$t('healthcheck.messagesPerHour')}`,
            },
          },
          limit: {
            enabled: true,
            scaleID: 'x',
            value: this.maxQueueLength,
            backgroundColor: COLORS.healthcheck.error,
            borderWidth: 1,
          },
        },
      };
    },
  },
  mounted() {
    this.fetchList();

    this.$socket.join(SOCKET_ROOMS.messageRates);
    this.$socket
      .getRoom(SOCKET_ROOMS.messageRates)
      .addListener((data) => {
        this.messagesStats = data;
      });
  },
  beforeDestroy() {
    this.$socket.leave(SOCKET_ROOMS.messageRates);
  },
  methods: {
    async fetchList() {
      this.pending = true;

      const to = getNowTimestamp();
      const from = subtractUnitFromDate(to, 1, TIME_UNITS.hour);

      const { data: messagesStats } = await this.fetchMessageRateStatsWithoutStore({
        params: {
          from,
          to,
          interval: MESSAGE_STATS_INTERVALS.minute,
        },
      });

      this.messagesStats = messagesStats;

      this.pending = false;
    },
  },
};
</script>
