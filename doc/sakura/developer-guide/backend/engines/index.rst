.. _dev-backend-engines:

Engines development
===================

.. toctree::
   :maxdepth: 2
   :titlesonly:

   howto
   scheduler
   filter


General purposes about engines
------------------------------

amqp2engine is the concept of linking some python code to process event in (python) engines that come from the amqp exchange. This is why there is as canopsis user a **amqp2engine** service that manage engines operation ``start, stop, restart`` for all engine described in the configuration explained below. This is also the name of the confuration files that manage these engines processes.

Stringed json events enter in canopsis through the ``canopsis`` vhost on the ``canopsis.events`` amqp exchange. This is where the first engine of the chain is awaiting events.

For instance the first engine of the chain is the ``engine cleaner`` event that preprocess all input event to make them clean for further canopsis processing.

Events are linked together as a **pipeline** processing. This is done thanks to the **amqp middleware** where event in three steps proccess each event.

- First, an event is gathered from it's dedicated queue
- Second the fetched event is processed
- Third The event is put into the next engine amqp queue (or dropped in some case)

Engines in canopsis are independant (unix) **daemon processes managed by supervisord**. Supervisord allow failover behaviors for engines that may not finnish properly.
This is why the `supervisord configuration have to be managed when adding a new engine`.

A dedicated engine queue may be **read by one or many engine** of the same type. Many engines are used in High availability system (Canopsis CAT)  or just as a help for  performance event processing purpose on many cores on a single server. The best configuration (number of engines of each type) is not generic and depends greatly on the underlaying hardware. Thats why there are some ``.ini`` configuration files for each engine telling **supervisord** how many engine of each type the amqp2engine command have to instanciate when the service is (re)started.

Event processing workflow
-------------------------

Engines can **process each incoming event independently** `(all from the engine queue reparted on availability of each engine of the same type)` if and only if the configuration of the amqp2engine specify an **event_processing** bind function. This function will be triggered for each event coming from the amqp middleware.

Engines can also perform any processing **each beat_interval** (configuration directive) seconds. This way any engine can perform some **asynchronous tasks** in canopsis environment. For instance, `some existing engine are only asynchronous based processing` and do not process each event. This can be done by not including these events in the event processing pipeline.

For **distributed** canopsis purposes, canopsis engine API also provide a **consume dispatcher method**. This method is called in the engine when an incomming event for the engine is available on the **Dispatcher_<enginename>** amqp queue. This event is generated by the dispatcher engine where it is possible some more engine to be triggered this way. This feature is similar as the beat one but, it is **triggered only once** for each engine of the same type. This is done to prevent from repeated beat_interval code execution on each engine for the beat method. This is useful to `avoid engines to process twice same code` at the same time when many instances of the same engine are created in the canopsis configuration.

Have a look at the `How to write an engine` section for more infomation about how to setup an engine in the Canopsis environment.
