/*
#--------------------------------
# Copyright (c) 2011 "Capensis" [http://www.capensis.com]
#
# This file is part of Canopsis.
#
# Canopsis is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Canopsis is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Canopsis.  If not, see <http://www.gnu.org/licenses/>.
# ---------------------------------
*/

// initComponent -> afterContainerRender 	-> setchartTitle -> ready -> doRefresh -> onRefresh -> addDataOnChart
//                                			-> setOptions                             			-> getSerie
//											-> createChart

flag_tootlip_template = Ext.create('Ext.XTemplate',
	'<table>',
		'<tr>',
			'<td style="margin:3px;">',
				'<tpl if="event_type == \'user\'">',
					'<img src="widgets/stream/logo/ui.png" style="width: 32px;"></img>',
				'</tpl>',
				'<tpl if="event_type != \'user\'">',
					'<img src="widgets/stream/logo/{icon}.png" style="width: 32px;"></img>',
				'</tpl>',
			'</td>',
			'<td>',
				'<div style="margin:3px;">',
					'<tpl if="display_name">',
							'<b>{display_name}</b>',
					'</tpl>',
					'<tpl if="display_name == undefined">',
						'<b>{component}</b>',
						'<tpl if="resource">',
							'<b> - {resource}</b>',
						'</tpl>',
					'</tpl>',
					' <span style="color:grey;font-size:10px">{date}</span>',
					'<br/>{text}',
				'</div>',
			'</td>',
		'</tr>',
	'</table>',
	{compiled: true}
);

Ext.define('widgets.mini_chart.mini_chart' , {
	extend: 'canopsis.lib.view.cwidget',

	alias: 'widget.mini_chart',

	wcontainer_layout: {
        type: 'vbox',
        align: 'center'
    },


	logAuthor: '[mini_chart]',
	initComponent: function() {
		console.log(this.nodes);
		if(Ext.isArray(this.nodes))
			this.nodesByID = parseNodes(this.nodes);
		else
			this.nodesByID = expandAttributs(this.nodes)

		this.series = {} ;
		this.callParent(arguments);
 	},
	doRefresh: function (from, to ) {
		console.log( "do Refresh");
		console.log( from ) ;
		console.log( to);
		if (this.nodesByID) {
			if (Ext.Object.getSize(this.nodesByID) != 0) {
				url = this.makeUrl(from, to);
				console.log(this.buildParams(from, to) ) ;
				Ext.Ajax.request({
					url: url,
					scope: this,
					params: this.buildParams(from, to),
					method: 'POST',
					success: function(response) {
						var data = Ext.JSON.decode(response.responseText);
						data = data.data;
						this.onRefresh(data);
					},
					failure: function(result, request) {
						log.error('Ajax request failed ... (' + request.url + ')', this.logAuthor);
					}
				});
			} else {
				log.debug('No nodes specified', this.logAuthor);
				this.chart.showLoading(_('Please choose a valid metric in wizard'));
			}
		}
		this.callParent(arguments);
	},
	buildParams: function(oFrom, oTo) {
		//TODO: Rebuild this with new format !

		var now = Ext.Date.now();
		var post_params = [];

		Ext.Object.each(this.nodesByID, function(id, node, obj) {
			var nodeId = id;
			var from = oFrom;
			var to = oTo;
			post_params.push({
				id: nodeId,
				metrics: node.metrics,
				from: parseInt(from / 1000),
				to: parseInt(to / 1000)
			});

		},this)

		return {
			'nodes': Ext.JSON.encode(post_params),
		};
	},
	makeUrl: function(from, to) {
		return '/perfstore/values' + '/' + parseInt(from / 1000) + '/' + parseInt(to / 1000);
	},
	onRefresh: function(data) {
		console.log("on refresh");
		for ( var i=0; i < data.length; i++ ) {
			var info = data[i];
			var node = info['node'] ;
			var values = info['values'];
			var new_values = new Array();
			for ( var j = 0; j < values.length; j++ ) {
				new_values.push( values[j][1] ) ;
			}
			this.series[node].add( {
				xtype:"panel",
				flex: 2,
				bodyCls: "valigncenter",
				html: "<div>"+info["metric"]+"</div>",
				border: false, 
			});
			var serie_panel = this.series[node].add ( {
				xtype: "panel",
				flex: 5,
				border: false
			} ) ;
			
			this.series[node].add( {
				xtype: "panel",
				flex: 1,
				bodyCls: "valigncenter padding-left",
				border: false,
				html : "<div><b>"+values[ values.length - 1][1]+"</b></div>"
			}) ;
			var metric = data[i].metrics[0] ;
			$('#'+serie_panel.getId() ).sparkline(values, {
					width: serie_panel.getWidth(),
					height: serie_panel.getHeight(),
					chartRangeMinX: values[0][0],
					chartRangeMaxX: values[values.length - 1][0],
					tooltipClassname: 'tooltip',
					metric: metric,
					unit: unit	
					tooltipFormatter: function(sparkline, options, fields) {
						return '<b>' + rdr_tstodate(Math.round(fields['x'])) + '</b><br>' + options.userOptions.metric + ': ' + fields['y'] + ' ' + options.userOptions.unit;
					} 
			});
		}
		this.callParent(arguments);
	},
	afterContainerRender: function() {
		console.log("after render");
		var me = this ;
		Ext.Object.each(this.nodesByID, function(id, node, obj) {
			console.log ( me.getSize().height ) ;
			console.log ( Ext.Object.getSize(me.nodesByID) ) ;
			console.log (  me.getSize().height / Ext.Object.getSize(me.nodesByID) ) ;
			var serie  = {
				layout: {
					type: "hbox",
					align: "stretch"
				},
				width: me.getSize().width,
				height: me.getSize().height / Ext.Object.getSize(me.nodesByID),
				border: false
			};
			console.log( serie ) ;
			me.series[id] = me.wcontainer.add( serie ) ;
//			console.log(  me.series[id].setHeight(  me.getSize().height / Ext.Object.getSize(me.nodesByID)  ) ) ;
		} ) ;
		
		
		this.callParent();
	}

});
