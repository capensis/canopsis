<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: definitions.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: definitions.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'
const arrayify = require('array-back')
const option = require('./option')
const Definition = require('./definition')
const t = require('typical')

/**
 * @module definitions
 * @private
 */

/**
 * @alias module:definitions
 */
class Definitions {
  constructor (definitions) {
    this.list = []
    arrayify(definitions).forEach(def => this.list.push(new Definition(def)))
    this.validate()
  }

  /**
   * validate option definitions
   * @returns {string}
   */
  validate (argv) {
    const someHaveNoName = this.list.some(def => !def.name)
    if (someHaveNoName) {
      halt(
        'NAME_MISSING',
        'Invalid option definitions: the `name` property is required on each definition'
      )
    }

    const someDontHaveFunctionType = this.list.some(def => def.type &amp;&amp; typeof def.type !== 'function')
    if (someDontHaveFunctionType) {
      halt(
        'INVALID_TYPE',
        'Invalid option definitions: the `type` property must be a setter fuction (default: `Boolean`)'
      )
    }

    let invalidOption

    const numericAlias = this.list.some(def => {
      invalidOption = def
      return t.isDefined(def.alias) &amp;&amp; t.isNumber(def.alias)
    })
    if (numericAlias) {
      halt(
        'INVALID_ALIAS',
        'Invalid option definition: to avoid ambiguity an alias cannot be numeric [--' + invalidOption.name + ' alias is -' + invalidOption.alias + ']'
      )
    }

    const multiCharacterAlias = this.list.some(def => {
      invalidOption = def
      return t.isDefined(def.alias) &amp;&amp; def.alias.length !== 1
    })
    if (multiCharacterAlias) {
      halt(
        'INVALID_ALIAS',
        'Invalid option definition: an alias must be a single character'
      )
    }

    const hypenAlias = this.list.some(def => {
      invalidOption = def
      return def.alias === '-'
    })
    if (hypenAlias) {
      halt(
        'INVALID_ALIAS',
        'Invalid option definition: an alias cannot be "-"'
      )
    }

    const duplicateName = hasDuplicates(this.list.map(def => def.name))
    if (duplicateName) {
      halt(
        'DUPLICATE_NAME',
        'Two or more option definitions have the same name'
      )
    }

    const duplicateAlias = hasDuplicates(this.list.map(def => def.alias))
    if (duplicateAlias) {
      halt(
        'DUPLICATE_ALIAS',
        'Two or more option definitions have the same alias'
      )
    }

    const duplicateDefaultOption = hasDuplicates(this.list.map(def => def.defaultOption))
    if (duplicateDefaultOption) {
      halt(
        'DUPLICATE_DEFAULT_OPTION',
        'Only one option definition can be the defaultOption'
      )
    }
  }

  /**
   * Initialise .parse() output object.
   * @returns {object}
   */
  createOutput () {
    const output = {}
    this.list.forEach(def => {
      if (t.isDefined(def.defaultValue)) output[def.name] = def.defaultValue
      if (Array.isArray(output[def.name])) {
        output[def.name]._initial = true
      }
    })
    return output
  }

  /**
   * @param {string}
   * @returns {Definition}
   */
  get (arg) {
    return option.short.test(arg)
      ? this.list.find(def => def.alias === option.short.name(arg))
      : this.list.find(def => def.name === option.long.name(arg))
  }

  getDefault () {
    return this.list.find(def => def.defaultOption === true)
  }

  isGrouped () {
    return this.list.some(def => def.group)
  }

  whereGrouped () {
    return this.list.filter(containsValidGroup)
  }
  whereNotGrouped () {
    return this.list.filter(def => !containsValidGroup(def))
  }

}

function halt (name, message) {
  const err = new Error(message)
  err.name = name
  throw err
}

function containsValidGroup (def) {
  return arrayify(def.group).some(group => group)
}

function hasDuplicates (array) {
  const items = {}
  for (let i = 0; i &lt; array.length; i++) {
    const value = array[i]
    if (items[value]) {
      return true
    } else {
      if (t.isDefined(value)) items[value] = true
    }
  }
}

module.exports = Definitions
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-command-line-args.html">command-line-args</a></li><li><a href="module-definition.html">definition</a></li></ul><h3>Classes</h3><ul><li><a href="module-command-line-args-CommandLineArgs.html">CommandLineArgs</a></li><li><a href="module-definition.html">definition</a></li><li><a href="module-definitions.html">definitions</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.2</a> on Fri Feb 12 2016 11:22:45 GMT+0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
