#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
env2cfg makes configuration in canopsis easier:

# export CPS_MONGO_URL="<valid_mongodb_url>"
# export CPS_REDIS_URL="redis://<ip>:<port>/<db>"
# export CPS_INFLUX_URL="<valid_influxdb_url>"
# export CPS_AMQP_URL="<valid_amqp_url>"
# env2cfg

Will write/update:

${CPS_PREFIX}/etc/cstorage.conf
${CPS_PREFIX}/etc/common/mongo_store.conf
${CPS_PREFIX}/etc/mongo/storage.conf

${CPS_PREFIX}/etc/influx/storage.conf

${CPS_PREFIX}/etc/amqp.conf
"""

from __future__ import unicode_literals

import logging
import os
import sys
from configparser import ConfigParser
from os.path import join as pjoin
from urlparse import urlparse

from pymongo import uri_parser
from pymongo.errors import ConfigurationError

from canopsis.common import root_path


class Env2Cfg(object):

    CPS_AMQP_URL = 'CPS_AMQP_URL'
    CPS_REDIS_URL = 'CPS_REDIS_URL'
    CPS_MONGO_URL = 'CPS_MONGO_URL'
    CPS_INFLUX_URL = 'CPS_INFLUX_URL'
    CPS_MONGO_REPLICASET_URL = 'CPS_MONGO_REPLICASET_URL'

    __mongo_replicaset_url_config_key = 'mongo_replicaset_url'

    @staticmethod
    def _check_empty(varname):
        varval = os.environ.get(varname, '')
        if varval is '':
            raise ValueError('env var {} is empty'.format(varname))

    def __check_mongo_dsn(self):
        mongo_url = os.environ.get(self.CPS_MONGO_URL)
        mongo_replicaset_url = os.environ.get(self.CPS_MONGO_REPLICASET_URL)
        if not (mongo_url or mongo_replicaset_url):
            raise ValueError('Env vars {}, {} are both empty. '
                             'You need to set at least one of them.'.format(self.CPS_MONGO_URL,
                                                                            self.CPS_MONGO_REPLICASET_URL))
        if mongo_replicaset_url:
            try:
                uri_parser.parse_uri(mongo_replicaset_url)
            except ConfigurationError:
                raise ValueError('Env var {} has invalid format'.format(self.CPS_MONGO_REPLICASET_URL))

    def check(self):
        self._check_empty(self.CPS_AMQP_URL)
        self._check_empty(self.CPS_REDIS_URL)
        self._check_empty(self.CPS_INFLUX_URL)
        self.__check_mongo_dsn()

    @staticmethod
    def _makedirs(fpath):
        dirs = os.path.dirname(fpath)
        if not os.path.isdir(dirs):
            os.makedirs(dirs)

    def _update_influx(self):
        pu = urlparse(os.environ.get(self.CPS_INFLUX_URL))

        p = pjoin(root_path, 'etc', 'influx', 'storage.conf')

        self._makedirs(p)

        influx = ConfigParser()

        influx.read(p)

        if 'DATABASE' not in influx.sections():
            influx.add_section('DATABASE')

        influx.set('DATABASE', 'host', 'localhost' if pu.hostname is None else pu.hostname)
        influx.set('DATABASE', 'port', '8086' if pu.port is None else str(pu.port))
        influx.set('DATABASE', 'db', 'canopsis' if pu.path is '' else pu.path[1:])
        influx.set('DATABASE', 'user', 'cpsinflux' if pu.username is None else pu.username)
        influx.set('DATABASE', 'pwd', 'canopsis' if pu.password is None else pu.password)

        with open(p, 'w') as fh:
            influx.write(fh)

    def _update_amqp(self):
        pu = urlparse(os.environ.get(self.CPS_AMQP_URL))

        p = pjoin(root_path, 'etc', 'amqp.conf')

        self._makedirs(p)

        amqp = ConfigParser()

        amqp.read(p)

        if 'master' not in amqp.sections():
            amqp.add_section('master')

        amqp.set('master', 'host', 'localhost' if pu.hostname is None else pu.hostname)
        amqp.set('master', 'port', '5672' if pu.port is None else str(pu.port))
        amqp.set('master', 'userid', 'cpsrabbit' if pu.username is None else pu.username)
        amqp.set('master', 'password', 'canopsis' if pu.password is None else pu.password)
        amqp.set('master', 'virtual_host', 'canopsis' if pu.path is '' else pu.path[1:])

        if amqp.get('master', 'exchange_name', fallback=None) is None:
            amqp.set('master', 'exchange_name', 'canopsis')

        with open(p, 'w') as fh:
            amqp.write(fh)

    class __DatabaseConf(object):
        def __init__(self, host, port, db, user, pwd):
            self.__host = host
            self.__port = port
            self.__db = db
            self.__user = user
            self.__pwd = pwd

        def update_database_conf(self, conf_store, section='DATABASE', user_key='user', password_key='pwd'):
            conf_store.set(section, 'host', self.__host)
            conf_store.set(section, 'port', self.__port)
            conf_store.set(section, 'db', self.__db)
            conf_store.set(section, user_key, self.__user)
            conf_store.set(section, password_key, self.__pwd)

    def __parse_mongo_url(self):
        pu = urlparse(os.environ.get(self.CPS_MONGO_URL))
        return self.__DatabaseConf(
            host='localhost' if pu.hostname is None else pu.hostname,
            port='27017' if pu.port is None else str(pu.port),
            db='canopsis' if pu.path is '' else pu.path[1:],
            user='cpsmongo' if pu.username is None else pu.username,
            pwd='canopsis' if pu.password is None else pu.password
        )

    def _update_mongo(self):

        pms = pjoin(root_path, 'etc', 'common', 'mongo_store.conf')
        pcs = pjoin(root_path, 'etc', 'cstorage.conf')
        ps = pjoin(root_path, 'etc', 'mongo', 'storage.conf')

        self._makedirs(pms)
        self._makedirs(pcs)
        self._makedirs(ps)

        mongo_store = ConfigParser()
        cstorage = ConfigParser()
        storage = ConfigParser()

        def _zip_configs_metadata():
            return zip([mongo_store, cstorage, storage],
                       [pms, pcs, ps],
                       ['DATABASE', 'master', 'DATABASE'],
                       ['user', 'userid', 'user'],
                       ['pwd', 'password', 'pwd'])

        for conf, fpath, section, _, _ in _zip_configs_metadata():
            conf.read(fpath)
            if section not in conf.sections():
                conf.add_section(section)

        if os.environ.get(self.CPS_MONGO_URL):
            database_conf = self.__parse_mongo_url()
            for conf, _, section, user_key, password_key in _zip_configs_metadata():
                database_conf.update_database_conf(conf, section, user_key, password_key)

        if os.environ.get(self.CPS_MONGO_REPLICASET_URL):
            for conf, _, section, _, _ in _zip_configs_metadata():
                conf[section][self.__mongo_replicaset_url_config_key] = \
                    os.environ[self.CPS_MONGO_REPLICASET_URL]

        for conf, fpath, _, _, _ in _zip_configs_metadata():
            with open(fpath, 'w') as fh:
                conf.write(fh)

    def _update_redis(self):
        pu = urlparse(os.environ.get(self.CPS_REDIS_URL))

        p = pjoin(root_path, 'etc', 'common', 'redis_store.conf')

        self._makedirs(p)

        redis = ConfigParser()

        redis.read(p)

        if 'DATABASE' not in redis.sections():
            redis.add_section('DATABASE')

        redis.set('DATABASE', 'host', 'localhost' if pu.hostname is None else pu.hostname)
        redis.set('DATABASE', 'port', '6379' if pu.port is None else str(pu.port))
        redis.set('DATABASE', 'dbnum', '0' if pu.path is '' else pu.path[1:])
        if pu.password:
            redis.set('DATABASE', 'pwd', pu.password)

        with open(p, 'w') as fh:
            redis.write(fh)

    def update(self):
        self._update_amqp()
        self._update_mongo()
        self._update_redis()
        self._update_influx()

    @staticmethod
    def main():
        app = Env2Cfg()
        try:
            app.check()
        except ValueError as ex:
            logging.error(ex)
            return 1

        app.update()
        return 0


if __name__ == '__main__':
    rc = Env2Cfg.main()
    sys.exit(rc)
